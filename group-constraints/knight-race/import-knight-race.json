{"formatVersion":"1","name":"New constraint","backend":{"type":"code","code":"for (const group of input.groups) {\n    const name = \"KnightRace_\" + helpers.naming.getCellsDescription(group.cells);\n    puzzle.addConstraintComponent(new KnightRaceComponent(name, group.cells));\n}"},"input":[{"id":"groups","label":"Groups","params":{"type":"raw"}}],"components":[{"type":"code","name":"KnightRaceComponent","code":"// Helper: Dynamic BFS for Knight distances\nfunction calculateDistances(size, cellCount) {\n    const dists = Array(cellCount).fill(0).map(() => Array(cellCount).fill(Infinity));\n    const moves = [\n        [-2, -1], [-2, 1], [-1, -2], [-1, 2],\n        [1, -2], [1, 2], [2, -1], [2, 1]\n    ];\n\n    for (let start = 0; start < cellCount; start++) {\n        const queue = [[start, 0]];\n        dists[start][start] = 0;\n        \n        let head = 0;\n        while(head < queue.length){\n            const [current, d] = queue[head++];\n            const r = Math.floor(current / size);\n            const c = current % size;\n\n            for (const [dr, dc] of moves) {\n                const nr = r + dr, nc = c + dc;\n                if (nr >= 0 && nr < size && nc >= 0 && nc < size) {\n                    const next = nr * size + nc;\n                    if (dists[start][next] === Infinity) {\n                        dists[start][next] = d + 1;\n                        queue.push([next, d + 1]);\n                    }\n                }\n            }\n        }\n    }\n    return dists;\n}\n\nfunction setParams(instance, cells) {\n    instance.cells = cells;\n}\n\nfunction* initialize(instance, puzzle) {\n    // Dynamic Size Detection\n    const size = puzzle.size || 9; \n    const cellCount = size * size;\n    \n    instance.gridSize = size;\n    instance.cellCount = cellCount;\n\n    // 1. Calculate and cache distances\n    instance.distMap = calculateDistances(size, cellCount);\n    \n    // Note: We no longer remove '1' from candidates. \n    // Cells CAN be 1 (implying another 1 is 1 step away).\n}\n\nfunction validate(instance, puzzle) {\n    const { cells, distMap, cellCount } = instance;\n\n    for (const cell of cells) {\n        if (!puzzle.hasValue(cell)) continue;\n\n        const cellValue = puzzle.getValue(cell);\n        \n        // Find actual distance to nearest '1' (excluding self)\n        let minDistance = Infinity;\n        let foundOne = false;\n\n        for (let i = 0; i < cellCount; i++) {\n            // IGNORE SELF: We look for the nearest *other* 1\n            if (i === cell) continue;\n\n            if (puzzle.hasValue(i) && puzzle.getValue(i) === 1) {\n                const d = distMap[cell][i];\n                if (d < minDistance) minDistance = d;\n                foundOne = true;\n            }\n        }\n\n        // If we found other '1's, check the distance\n        if (foundOne) {\n            // The value must match the distance exactly.\n            // If the actual closest 1 is CLOSER than our value, it's definitely broken.\n            if (minDistance < cellValue) return false;\n        }\n    }\n    return true;\n}\n\nfunction* update(instance, puzzle) {\n    const { cells, distMap, gridSize, cellCount } = instance;\n\n    // Identify '1' locations\n    const fixedOnes = [];\n    const possibleOnes = [];\n\n    for (let i = 0; i < cellCount; i++) {\n        if (puzzle.hasValue(i)) {\n            if (puzzle.getValue(i) === 1) fixedOnes.push(i);\n        } else if (puzzle.getCandidates(i).has(1)) {\n            possibleOnes.push(i);\n        }\n    }\n\n    // PART A: Restrict candidates in constrained cells\n    for (const cell of cells) {\n        let minTheoDist = Infinity;\n        \n        // Check fixed ones (excluding self)\n        for (const idx of fixedOnes) {\n            if (idx === cell) continue; // Skip self\n            const d = distMap[cell][idx];\n            if (d < minTheoDist) minTheoDist = d;\n        }\n        \n        // Check possible ones (excluding self)\n        for (const idx of possibleOnes) {\n            if (idx === cell) continue; // Skip self\n            const d = distMap[cell][idx];\n            if (d < minTheoDist) minTheoDist = d;\n        }\n\n        // Calculate Upper Bound (closest fixed 1, excluding self)\n        let maxTheoDist = Infinity;\n        for (const idx of fixedOnes) {\n            if (idx === cell) continue; // Skip self\n            const d = distMap[cell][idx];\n            if (d < maxTheoDist) maxTheoDist = d;\n        }\n\n        // Cap distances at grid size\n        if (minTheoDist > gridSize) minTheoDist = gridSize;\n        if (maxTheoDist > gridSize) maxTheoDist = gridSize;\n\n        // Filter: Value must be >= minTheoDist AND <= maxTheoDist\n        const allowed = [];\n        for (let v = 1; v <= gridSize; v++) {\n            if (v >= minTheoDist && v <= maxTheoDist) {\n                allowed.push(v);\n            }\n        }\n\n        if (allowed.length === 0) {\n            yield puzzle.stop`Cell ${helpers.naming.getCellsDescription([cell])} cannot reach another '1' within valid distance`;\n        } else {\n            yield puzzle.filterCandidatesInCells(\n                SudokuDigitSet.from(allowed),\n                [cell]\n            );\n        }\n    }\n\n    // PART B: Back-propagation\n    // If cell has value V, no *other* cell at distance < V can be '1'\n    for (const cell of cells) {\n        if (puzzle.hasValue(cell)) {\n            const val = puzzle.getValue(cell);\n            \n            const tooCloseCells = [];\n            for (let i = 0; i < cellCount; i++) {\n                if (i === cell) continue; // Skip self\n\n                // If 'i' is closer than 'val', it cannot be a '1'\n                if (distMap[cell][i] < val) {\n                    tooCloseCells.push(i);\n                }\n            }\n\n            if (tooCloseCells.length > 0) {\n                yield puzzle.removeCandidatesFromCells(\n                    SudokuDigitSet.from([1]),\n                    tooCloseCells\n                );\n            }\n        }\n    }\n}"}]}